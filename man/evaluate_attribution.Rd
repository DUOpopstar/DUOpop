% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/evaluate_attribution.R
\name{evaluate_attribution}
\alias{evaluate_attribution}
\title{Evaluate Attribution Metrics for Synthetic Data Privacy}
\usage{
evaluate_attribution(
  orig_df,
  syn_df,
  keys,
  target,
  train_df = NULL,
  holdout_df = NULL,
  na_as_value = TRUE
)
}
\arguments{
\item{orig_df}{A data frame containing the original data set.}

\item{syn_df}{A data frame containing the synthetic data set.}

\item{keys}{A character vector of column names representing quasi-identifiers (\code{q}).}

\item{target}{A character string specifying the name of the target column (\code{t}).}

\item{train_df}{Optional: A data frame containing the data used to base the synthetic data on in the case of a holdout set. When a training data set is passed, the original data set will not be used in this function.}

\item{holdout_df}{Optional: A data frame containing the out-of-sample (real) data not used during synthesis. The training data also needs to be provided.}

\item{na_as_value}{Logical; if \code{TRUE} (default), treat \code{NA} as a separate category/value in both target and key columns.}
}
\value{
A named list with attribution metrics:
\describe{
\item{• BaseCAP}{Minimal disclosure when only the marginal distribution of \code{t} is known. Let \eqn{p_t} be the relative frequency of target value \eqn{t}:
\deqn{\text{BaseCAP} = \sum_{t \in T} p_t^2}}
\item{• CAPo}{Maximum disclosure in the original data, assuming full access:
\deqn{\text{CAPo} = \sum_{q,t} \frac{n_{qt}}{n_q} \times \frac{n_{qt}}{N}}}
\item{• CAPs}{Total disclosure, including group and attribution, in the synthetic data:
\deqn{\text{CAPS} = \sum_{q,t} \frac{n_{qt}^{syn}}{n_q^{syn}} \times \frac{n_{qt}^{orig}}{N_{orig}}}}
\item{• hCAPs}{(If \code{holdout_df} is supplied) Desired group-level signal in synthetic data:
\deqn{\text{hCAPs} = \sum_{q,t} \frac{n_{qt}^{syn}}{n_q^{syn}} \times \frac{n_{qt}^{hold}}{N_{hold}}}}
\item{• Disc_Plot}{A plot visualising the four disclosure metrics.}
}

If \code{holdout_df} is supplied:
\describe{
\item{• Upperbound_Attr}{\eqn{CAPo - hCAPs}, upper bound on attribute info in original data}
\item{• Undesired_Attr}{\eqn{CAPs - hCAPs}, residual attribute info in synthetic data}
\item{• Abs_Attr_Reduction}{\eqn{Upperbound\_Attr - Undesired\_Attr}}
\item{• Rel_Attr_Reduction}{\eqn{1 - \frac{Undesired\_Attr}{Upperbound\_Attr}}, proportional reduction: how much of the original attribute disclosure is hidden in the synthetic data}
}

If \code{holdout_df} is not supplied:
\describe{
\item{• Abs_Reduction}{\eqn{CAPo - CAPs}, total disclosure drop as percentage points}
\item{• Rel_Reduction}{\eqn{\frac{CAPo - CAPs}{CAPo}}, total disclosure drop as a percentage}
\item{• Normalized_Disc}{\eqn{\frac{CAPs - BaseCAP}{CAPo - BaseCAP}}, normalized disclosure drop}
}
}
\description{
Calculates a set of attribute disclosure metrics to evaluate the privacy of synthetic data.
These metrics quantify how much information an attacker could infer about a target variable \code{t}
given access to quasi-identifiers \code{q}, under different assumptions.

If a holdout set is provided, the metrics can isolate and evaluate only the undesired attribute-level
information. This allows the evaluation to exclude desired group-level information and instead focus
on the residual, potentially sensitive individual-level information that remains in the synthetic data.
}
\details{
By default, \code{NA} values are treated as valid categories for both target and key columns (i.e., treated as any other value in the frequency tables).
This gives higher scores compared to when they are not treated as their own values.
Typically missing values are not considered a privacy risk. But there are cases where they should be counted towards key or target values.
This distinction is important when \code{NA} represents a true category (e.g., "not applicable") rather than a missing value.
If \code{use_na_as_value = FALSE}, then \code{NA} values in the target or quasi-identifiers are not treated as actual values, but all rows—including
those with \code{NA}—are still included in the denominators.

Empty strings ("") are treated as values.

Metrics include:
\itemize{
\item \strong{BaseCAP}: Baseline disclosure based only on the marginal distribution of \code{t} (see: \code{\link{calculate_basecap}})
\item \strong{CAPo}: Disclosure in the original data when the attacker knows \code{q} (see: \code{\link{calculate_capo}})
\item \strong{CAPs}: Disclosure in the synthetic data, combining group and attribute info (see: \code{\link{calculate_caps}})
\item \strong{hCAPs}: Group-level info retained by the synthetic data (see: \code{\link{calculate_hcaps}})
\item Disclosure reduction metrics comparing CAPs to CAPo
}
}
\examples{
\dontshow{if (requireNamespace("synthpop", quietly = TRUE)) (if (getRversion() >= "3.4") withAutoprint else force)(\{ # examplesIf}
vars <- c("age", "sex", "marital", "income", "ls", "smoke")
orig_df <- synthpop::SD2011[, vars]

set.seed(123)
idx <- sample(seq_len(nrow(orig_df)), size = 0.8*nrow(orig_df))
train_df <- orig_df[idx, ]
holdout_df <- orig_df[-idx, ]
syn_df <- synthpop::syn(train_df)$syn

attr <- evaluate_attribution(orig_df, syn_df, keys = c("age", "sex"), target = "marital", train_df, holdout_df, na_as_value = TRUE)
\dontshow{\}) # examplesIf}
}
